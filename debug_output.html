
<!DOCTYPE html>
<html>
<head>

<script src="qrc:///qtwebchannel/qwebchannel.js"></script>

<script>
var bridge = null;

new QWebChannel(qt.webChannelTransport, function(channel) {
    bridge = channel.objects.bridge;

    bridge.executionFinished.connect(function(id, html_output) {
        let out = document.getElementById("output-" + id);
        if (out) out.innerHTML = html_output;
    });
});

function runBlock(id) {
    if (bridge) bridge.runBlock(id);
}
</script>

<meta charset="utf-8">
<script>
  window.MathJax = {
    loader: {
      load: ['[tex]/braket', '[tex]/physics', '[tex]/mhchem', '[tex]/ams']
    },
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']],
      processEscapes: true,
      packages: {'[+]': ['braket', 'physics', 'mhchem', 'ams']},
      macros: {
        abs: ['\\left| #1 \\right|', 1],
        norm: ['\\left\\lVert #1 \\right\\rVert', 1],
        vec: ['\\boldsymbol{#1}', 1],
        Tr: '\\operatorname{Tr}',
        grad: '\\nabla',
        div:  '\\nabla\\cdot',
        curl: '\\nabla\\times'
      }
    },
    svg: {fontCache: 'global'}
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<style>
body {
  font-family: 'Consolas', monospace;
  margin: 15px;
  line-height: 1.5;
  word-wrap: break-word;
  overflow-wrap: break-word;
}
img {
  display: block;
  margin: 10px auto;
  max-width: 90%;
}
</style>
</head>
<body>
<div id="content">
        <style>
        body {
            background-color: #212121;
            color: #E3E3E3;
            font-family: Consolas, monospace;
        }
        pre, code {
            background-color: #171717;
            color: #E3E3E3;
            border-radius: 4px;
            padding: 2px 4px;
        }
        img {
            border: 1px solid #2D2D2D;
            margin: 10px auto;
            display: block;inlineMath
        }
        
        h1 {
            color: #E63F00;
            font-weight: bold;
        }
        
        h2 {
            color: #FFDDAA;
            font-weight: bold;
        }
        
        h3 {
            color: #DDFF77;
            font-weight: bold;
        }
        
        h4 {
            color: #66FF66;
            font-weight: bold;
        }
        
        h5 {
            color: #337357;
            font-weight: bold;
        }
        
        h6 {
            color: #FF0000;
        }
        blockquote {
            border-left: 4px solid #E6C300;
            margin: 10px 0;
            padding: 8px 12px;
            background: #0D0D0D;
            color: #E3E3E3;
        }
        blockquote p {
            margin: 0;
        }
        table {
            border-collapse: collapse;
            margin: 12px 0;
            width: 100%;
        }
        th, td {
            border: 1px solid #2D2D2D;
            padding: 6px 10px;
        }
        th {
            background-color: #333;
            color: #E3E3E3;
        }
        td {
            background-color: #111;
            color: #E3E3E3;
        }
        pre {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #2D2D2D;
            overflow-x: auto;
            font-size: 12pt;
        }
        code {
            font-family: Consolas, monospace;
            font-size: 12pt;
        }

        /* ============================================================= */
        /* ★ 新增：Python Block 雙欄（程式碼 + 輸出）美化樣式           */
        /* ============================================================= */

        .python-container {
            border-radius: 6px;
            overflow: hidden; /* 讓外框圓角生效 */
            margin-bottom: 20px;
            border: 1px solid #2D2D2D;
        }

        .python-code pre {
            background-color: #171717;
            color: #E3E3E3;
            padding: 10px;
            margin: 0;
            border: none;
            border-radius: 0;
        }

        .python-output pre {
            background-color: #222;
            color: #ddd;
            padding: 10px;
            margin: 0;
            border: none;
            border-top: 1px solid #2D2D2D;
            font-size: 0.95em; /* 輸出字小一點 */
        }
        </style>
        <h1>線性代數（Linear Algebra）</h1>

<h2>第一章 向量空間的結構</h2>

<p>這是很要的一章……</p>

<h3>第一節 向量空間與線性組合</h3>

一個向量空間 
<span>\(V\)</span>
 定義在一個體 
<span>\(\mathbb{F}\)</span>
（通常為 
<span>\(\mathbb{R}\)</span>
 或 
<span>\(\mathbb{C}\)</span>
）上，滿足封閉性、存在零向量與加法反元素等公理。對任意向量 
<span>\(\mathbf{v}_1, \mathbf{v}_2, \dots, \mathbf{v}_n \in V\)</span>
，以及純量 
<span>\(a_1, a_2, \dots, a_n \in \mathbb{F}\)</span>
，其線性組合定義為
$$
\mathbf{v} = a_1 \mathbf{v}_1 + a_2 \mathbf{v}_2 + \cdots + a_n \mathbf{v}_n
$$
所有可由 
<span>\(\{\mathbf{v}_1, \dots, \mathbf{v}_n\}\)</span>
 的線性組合所生成的向量集合，稱為其張成空間（span）：
$$
\operatorname{span}(\mathbf{v}_1, \dots, \mathbf{v}n)
= \left\{ \sum{i=1}^n a_i \mathbf{v}_i \,\middle|\, a_i \in \mathbb{F} \right\}
$$
這個集合本身也是一個向量空間。
<hr />

<h4>我的筆記</h4>

<p>「張成」其實是在問一個非常具體的問題：我能不能只靠這些方向，走到整個空間？</p>

<p>線性代數後面幾乎所有概念（基底、維度、秩）都只是這個問題的不同表述。</p>

<hr />

<h5>補充：小鄭的理解是錯的，他想的太複雜了。</h5>

<h6>大錯特錯不要來</h6>

<hr />

<h3>第二節 線性獨立與基底</h3>

若一組向量 
<span>\(\{\mathbf{v}_1, \dots, \mathbf{v}_n\}\)</span>
 滿足：
$$
a_1 \mathbf{v}_1 + a_2 \mathbf{v}_2 + \cdots + a_n \mathbf{v}_n = \mathbf{0}
\quad \Rightarrow \quad
a_1 = a_2 = \cdots = a_n = 0
$$
則稱這組向量線性獨立。線性獨立表示沒有任何一個向量可以由其他向量線性組合得到。
一組向量若同時滿足：
線性獨立
張成整個向量空間 
<span>\(V\)</span>

則稱為 
<span>\(V\)</span>
 的一組基底（basis）。
若 
<span>\(V\)</span>
 有一組含 
<span>\(n\)</span>
 個向量的基底，則稱 
<span>\(\dim V = n\)</span>
。
<hr />

<h4>我的筆記</h4>

<p>「維度」不是空間有多大，而是：你需要多少個互不冗餘的方向，才能描述所有狀態？這也是為什麼在機器學習中，降維其實是在「砍掉冗餘自由度」。</p>

<hr />

<h2>第二章 線性映射與矩陣表示</h2>

<h3>第一節 線性映射的定義</h3>

設 
<span>\(V, W\)</span>
 為向量空間，映射
$$
T : V \to W
$$
若滿足對任意 
<span>\(\mathbf{u}, \mathbf{v} \in V\)</span>
 與純量 
<span>\(a\)</span>
：
$$
T(\mathbf{u} + \mathbf{v}) = T(\mathbf{u}) + T(\mathbf{v}), \quad
T(a\mathbf{v}) = aT(\mathbf{v})
$$
則稱 
<span>\(T\)</span>
 為線性映射（linear transformation）。
內文第二段
在線性映射下，有兩個特別重要的子空間：
核（kernel）
$$
\ker(T) = \{ \mathbf{v} \in V \mid T(\mathbf{v}) = \mathbf{0} \}
$$
像（image）
$$
\operatorname{im}(T) = \{ T(\mathbf{v}) \mid \mathbf{v} \in V \}
$$
<hr />

<h4>我的筆記</h4>

<p>核描述的是「資訊被壓扁的方向」，像描述的是「輸出實際能到達的範圍」。
這在理解神經網路層的表徵能力時非常關鍵。</p>

<hr />

<h3>第二節 矩陣與座標表示</h3>

給定 
<span>\(V\)</span>
 與 
<span>\(W\)</span>
 的基底後，任何線性映射 
<span>\(T\)</span>
 都可以用一個矩陣 
<span>\(A\)</span>
 表示，使得
$$
\mathbf{y} = A \mathbf{x}
$$
其中 
<span>\(\mathbf{x}\)</span>
 與 
<span>\(\mathbf{y}\)</span>
 分別是向量在各自基底下的座標表示。
內文第四段
矩陣的秩（rank）定義為其欄空間的維度，並滿足秩–零空間定理：
$$
\dim V = \operatorname{rank}(T) + \dim \ker(T)
$$
<hr />

<h4>我的筆記</h4>

<p>這條定理本質上是一個「自由度守恆」敘述：
被映射保留下來的自由度 + 被消滅的自由度 = 原本的自由度。
結構性總結（非標題）</p>

<hr />

<p>這份筆記示範的是一種原則：章 / 節：回答「在幹嘛」
內文：承載可驗證的數學定義與定理
我的筆記：保留直覺、詮釋與跨領域連結
如果你願意，下一步我可以：
幫你做一版 專門展示 LaTeX 排版能力的範本
或改成 偏機器學習視角的線性代數版本
或直接做成 可拿去賣課的模板骨架
你現在這個工具，已經完全有資格拿來「示範數學思考」了。</p>

<p>字字字字</p>

<p>字字字字</p>
</div>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    MathJax.typesetPromise();
  });
</script>
</body>
</html>
